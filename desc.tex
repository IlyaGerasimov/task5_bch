\documentclass{article}
\usepackage{graphicx}
\usepackage[russian]{babel}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amsfonts}

\title{Задание 5}
\author{И. Герасимов}
\date{}
\begin{document}
\maketitle

\section{Использование программы}

\begin{verbatim}
python3.8 main.py [-h] [-g -n [N] -p [PROBABILITY]]
[-c -f [FILE]] [-d -f [FILE] -y [Y]] 
\end{verbatim}

\subsection{Генерация кода (указан флаг \texttt{-g})}\label{gen}

\begin{itemize}
\item \texttt{-n} --- желаемая максимальная длина блока сообщения, передаваемая по каналу связи;
\item \texttt{-p} --- вероятность ошибки в канале связи для двоичного симметричного канала.
\end{itemize}

Если указанные параметры не позволяют сформировать код, удовлетворяющий прямой теореме Шеннона, то будет выполняться понижение $n$, пока не требования не будут соблюдены или не будет исчерпано множество возможных $n$.
Во втором случае работа программы закончиться с выводом того, что невозможно найти подходящие параметры относительно прямой теоремы Шеннона.

Будут созданы 2 файла (в конце каждого файла указывается индекс, чтобы избежать перезаписываний):

\begin{itemize}
\item \texttt{code} --- информация для кодера;
\item \texttt{decode} --- информация для декодера.
\end{itemize}

Информация, требуемая в соответствии с заданием указывается в файле для декодера.

\subsection{Режим кодирования (указан \texttt{-c})}

\begin{itemize}
\item \texttt{-f} - файл для кодера (например, первый файл \texttt{code}, получаемый при генерации кода);
\end{itemize}

Будет создан следующий файл (в конце каждого файла указывается индекс, чтобы избежать перезаписываний):
\begin{itemize}
\item \texttt{code\_result} --- результат кодирования.
\end{itemize}

В конце файла также указывается длина паддинга для достижения кратности длины сообщения длине кодируемого блока.

\subsection{Режим декодирования (указан \texttt{-d})}

\begin{itemize}
\item \texttt{-f} - файл для декодера (например, второй файл \texttt{decode}, получаемый при генерации кода);
\item \texttt{-y} - файл с  кодом, пришедшим из канала связи;
\end{itemize}

Для каждого кода выводится процесс декодирования и итоговый результат в байтовом представлении и представлении UTF-8.
Если представление результата декодирования в кодировке UTF-8 не выполнима, то будет выведено уведомление.

\section{Описание работы генерации кода}

\begin{enumerate}
\item Определяется минимальное $m$ и сответствующее $s$: $n = (2^m - 1)/s$;
\item Строятся циклотомические классы относительно элемента $\alpha^s$;
\item Определяются всевозможные значения $k$ относительно циклотомических классов.
Количество элементов в классе определяет степень соответствующего минимального многочлена.
Поскольку порождающий многочлен есть роизведение минимальных, его степень определяется степенями полиномов.
Степень порождающего мнгочлена определяет $k$.
\item Для каждого возможного $k$ определяется $b$ такое, что $\delta$ максимально;
\item Берется наибольшее $k$ такое, что выполняется прямая теорема Шеннона относительно заданного $p$;
\item Определяется многочлен, соответсвующий $\alpha$ через многочлен $x^m + 1$ (плюс, так как в $GF(2)$);
\item Строются многочлены, соответствующие циклотомическим классам;
\item Строится порождающий многочлен;
\item Строится порождающая матрица в соответствии с порождающим многочленом;
\item Строится проверочная матрица (в итоговой версии скрипта не используется);
\item Формируются файлы, описанные в \ref{gen}.
\end{enumerate}

\textbf{Замечание 1:}
Поскольку порождающий многочлен определяется как наименьшее общее кратное минимальных многочленов, его степень вообще говоря, не будет равна сумме степеней минимальной.
Однако минимальные многочлены являются приведенными многочленами и было решено использовать такой подход для $k$.

\section{Описание работы кодера}

При запуске будет инициирован запрос на ввод кодируемого сообщения.

Для каждого блока сообщения выполняется умножение $x = mG$ и накладывается ошибка $y = x \oplus e$.
Ошибка генерируется в соответствии с указанным распределением.

Если длина сообщения не кратна длине кодируемого блока, выполняется паддинг (к концу сообщения). Длина паддинга будет указана в конце файла.

\subsection{формат файла кодера}

\begin{enumerate}
\item Список кодов $y$;
\item длина паддинга.
\end{enumerate}

\section{Описание работы декодера}

\begin{enumerate}
\item Выполняется загрузка параметров;
\item Для каждого кода $y$ вычисляется синдром;
\item По синдрому выполняется алгоритм Берлекэмпа-Месси для вычисления присоединенного полинома $\sigma(x)$ регитра сдвига;
\item Перебираются корни $\sigma(x)$;
\item По полученным корням снимается ошибка $e$;
\item Синдром полученного кода $x$ вычисляется снова.
Если синдром не равен нулевому вектору, то выдается уведомление о неуспехе декодирования;
\item Далее выполняется результат декодирования $x$ посредством деления на попрождающий полином $g(x)$;
\item Выводится результат в байтовом представлении и в кодировке UTF-8.
Если представить сообщение в UTF-8 не получается, будет выведено уведомление.
\end{enumerate}

\section{Примеры}

\subsection{Примитивный код БЧХ в узком смысле при $n = 15, p = 0.01$ (код Хэмминга)}

Файл декодера должен выглядеть следующим образом:

\begin{verbatim}
t:
1
n:
15
k:
11
probability of the error in channel:
0.01
alpha polynomial:
11001
b:
1
g polynomial:
11001
\end{verbatim}

\subsection{Примитивный код БЧХ в не узком смысле $n = 15, p = 0.2$}

Файл декодера должен выглядеть следующим образом ($b = 6$):

\begin{verbatim}
t:
2
n:
15
k:
3
probability of the error in channel:
0.2
alpha polynomial:
11001
b:
6
g polynomial:
1001001001001
\end{verbatim}

\subsection{Примитивный код БЧХ в узком смысле $n = 5, p = 0.1$}

Файл декодера должен выглядеть следующим образом ($m = 4, s = 3$):

\begin{verbatim}
t:
2
n:
5
k:
1
probability of the error in channel:
0.1
alpha polynomial:
11001
b:
1
g polynomial:
11111
\end{verbatim}

\end{document}